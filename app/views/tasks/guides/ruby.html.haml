#submission-guide
  :markdown
    # Как да (не) си изпращаме задачите

    Тук ще намерите кратки (или не толкова кратки) инструкции за това как да си изпращате
    задачите.

    ## Накракто

    * Прочетете си условието **внимателно** и дори няколко пъти.
    * След като сте написали решение, изпълнете примерния тест.
    * Преди да опитате да изпратите решение през сайта, изпълнете стилистическата проверка на вашия компютър.
    * Не споделяйте решението си с никого.
    * Не гледайте чужди решения.

    ## Преписване и споделяне на решения

    Всички решения стават публични след крайния срок на задачата. Преди това всякакво споделяне
    на решения е забранено.

    Това включва:

    * Да пратите решението си на някой друг.
    * Да го покажете на другарче, за да "почерпи идеи".
    * Да го сложите някъде публично преди крайния срок (например GitHub).

    Ако хванем, че сте преписвали, ви късаме без много-много обяснения и губите всичките си
    точки от задачи. Когато се видим през септември, схемата за оценява продължава да важи за
    вас и вие продължавате да имате 0 точки от задачи. Това означава, че се борите за 3 или 4.
    Ако сте много нахални, санкциите могат да бъдат по-тежки.

    Често виждаме двойка решения, едното от които е променено за да изглежда различно. Това
    се хваща по-лесно, отколкото си мислите. Имаме достъп до всички задачи, които сте предали,
    както и до тези на другарчето ви. Ако решим, че случая е такъв, няма да даваме
    много обяснения. По-добре не го правете.

    От друга страна, не се притеснявайте да напишете най-простия възможен код, понеже
    "други хора ще предадат същото решение". Това също се разпознава лесно, и разбира се,
    няма да сметнем, че сте преписвали. Пишете най-добрия код, на който сте способни,
    не споделяйте решенията си и няма да има причина да се притеснявате, че ще помислим,
    че сте преписвали.

    ## От какво имате нужда

    Тестовете, с които проверяваме домашните, са написани с [RSpec](http://relishapp.com/rspec).
    Това е интересен тестов framework за Ruby. Стиловите изисквания към кода ви се проверяват
    с библиотека, която сме написали специално за курса - [skeptic](http://github.com/skanev/skeptic).
    Всичко това се случва в Ruby 2.1.

    Ако пращате задача за първи път, първо се уверете, че използвате Ruby 2.1.

        $ ruby -v
        ruby 2.1.0dev (2013-09-22 trunk 43011) [x86_64-darwin11.4.2]

    Ако версията не започва с 2.1, значи сте на грешна такава. Качете си Ruby 2.1, понеже между двете има
    достатъчно разлики, за да работи едно решение при вас, но да не работи при нас.

    След това си инсталирайте нужните библиотеки:

        $ gem install rspec skeptic

    Ако получите грешка, че не съществува команда `gem`, значи имате проблем с инсталацията на Ruby.
    Инсталирайте го отново и този път се уверете, че сте качили RubyGems.

    ## Примерен тест

    С всяка задача публикуваме примерен тест в [GitHub хранилището](http://github.com/fmi/ruby-homework).
    Задължително **изтеглете теста и го пуснете**. За да го направите, трябва да си качите rspec. Това
    След това запишете решението си като `solution.rb` и изпълнете теста така:

        $ rspec sample_spec.rb --require ./solution.rb --colour --format documentation

    Обърнете внимание, че трябва да поставите `./` пред файла с решението в Ruby 2.1.

    ## Стилистическа проверка

    Всяка задача има стилистически изисквания, на които условието ви трабва да отговаря.
    Сайтът не приема решения, които не ги покриват.

    Преди да опитате да изпратите решение на сайта, може да изпълните стилистическата
    проверка на вашия компютър. В условието може да намерите командата, с която да го
    направите. Обикновено изглежда по подобен начин:

        $ skeptic --methods-per-class 7 --lines-per-method 5 solution.rb

    Това проверява дали в `solution.rb` класовете имат най-много по 7 метода и методите имат
    най-много по 5 реда.

    Ако смятате, че има грешка в примерния ни тест или в skeptic и искате да се свържете с нас,
    пишете на форумите. **В никакъв случай не споделяйте решението си публично**. Напишете
    кратка Ruby програма която пресъздава проблема и споделете нея вместо това. Ако смятате,
    че няма как да стане без да видим решението ви, пишете ни на <fmi@ruby.bg> и прикачете
    решението си. Или още по-добре, направете **private** [gist](http://gist.github.com) и ни
    пратете линк към него. Ако споделите решението си публично (форумите или публичен gist),
    ще смятаме това за преписване.

    Обърнете внимание, че е относително лесно да заобиколите ограниченията. Например, ако си
    кръстите променливите с по една буква, ще се справите лесно с ограничението за дължина на ред.
    Ако разбиете метода `calculate` на `calculate_1`, `calculate_2` и `calculate_3`, които да
    си общуват с полета, лесно ще заобиколите ограничението за дължина на метод. Ако дефинирате
    метод с `define_method`, може да подминете ограничението за брой методи в клас.
    Ако сложите всичко в един `eval`, skeptic въобще няма да се усети да го анализира.

    Не пасем трева. Ако сте направили така, резултата ще варира от това да ви вземем няколко точки
    за стил, до това въобще да не ви дадем точко на задачата. Идеята на тези ограничения е да ви
    провокират да помислите как да структурирате кода си по-добре и да стане по-четим, а не да
    измисляте креативни начини да заобикаляте статичния анализ на кода.

    Следва списък с ограниченията. Това не е финална версия - с времето ще се изменя.
    Консултирайте го, ако не разбирате какъв е проблема с кода ви.

    ### Максимално ниво на влагане

    Един метод трябва да е прост и лесно да показва какво прави със структурата си. Съответно,
    всеки метод трябва да има най-много X нива на влагане.

    За ниво на влагане се брои:

    * Блокове (`each`, `map` и прочее)
    * Условия (`if`, `unless` и `case` във всичките им форми, както и `? :`)
    * Ламбди
    * `begin/end` блокове
    * Цикли (`while`, `until`, `for`)

    Тези неща важат в рамките на един метод - `class`, `module` и `def` не се броят за нива
    на влагане.

    Ако метод не отговаря на това ограничение, може да опитате следните неща:

    * Разбийте метода на няколко отделни. Всеки трябва да прави едно нещо и да е относително
      изолиран от останалите.
    * Използвайте локални променливи за да дадете име на израз, който е в по-дълбоко ниво на
      влагане.
    * Потърсете дали няма начин да напишете нещо с по-малко нива на влагане. Обикновено има.

    ### Брой редове в метод

    Дългите методи са трудни за разбиране. Това обикновено е сиптом, че един метод прави твърде много
    неща и може да се раздели на няколко. Съответно, всеки метод може да има най-много X реда.

    За редове се броят:

    * `def`-а на метода не се брои.
    * Празни редове не се броят.
    * Редове с коментари не се броят.
    * Редове, на които има само `end` не се броят.
    * Отделно, няколко екзотични случая не се броят за ред, но тях няма да ви ги казваме.

    Ако метод не отговаря на това ограничение, може да опитате следните неща:

    * Идентифицирайте няколко неща, които този метод прави и изнесете всяко в отделен.
      Сведете метода до извикване на други (`private`) методи в същия клас.
    * Всеки от новите методи трябва да е кохезивен (да прави едно нещо) и да е добре
      изолиран (да разчита само на параметрите си и от полета, които не се променят от
      други методи)
    * Потърсете по-кратък запис на нещо, което правите. Може би сложна итерация може да
      стане с `#map` и `#select` или пък в `Array` има удобен метод, който имплементира
      това, което се опитвате да направите.

    ### Брой методи в клас

    Един клас трябва да прави точно едно нещо и да има точно една причина да се променя.
    Дългите класове са трудни за разбиране. Класовете които правят няколко неща са трудни
    за разбиране. Съответно, всеки клас може да има най-много Х метода.

    За методи се броят:

    * Методи на инстанциите класа.
    * Класови методи.
    * `attr_accessor`, `attr_reader` и прочее не се броят за методи.

    Ако клас не отговаря на това ограничение, може да опитате следните неща:

    * Идентифицирайте няколко неща, които класът прави, и създайте отделни класове за всяко.
      Създавайте инстанция на новите класове и я ползвайте за да извършите изчислението.
    * Не се притеснявайте да дефинирате повече класове. Повече прости класове е по-добре от
      по-малко, но сложни.
    * Не създавайте "utility" класове/модули, в които има само класове методи.

    ### Без ; като разделител на изрази

    Не ползвайте ; като разделител за изрази. Вместо това, напишете изразите на отделни редове.
    Така кодът е по-прегледен е по-ясно какво прави.

    ### Дължина на редове

    Дългите редове са трудни за четене. Не могат да се видят ясно на един екран. Често,
    голямата дължина е признак, че един ред прави твърде много неща. Съответно, всеки ред
    трябва да е най-много Х символа дълъг.

    Ако един ред не отговаря на това ограничение, разделете го на няколко отделни изрази,
    всеки от който присвоете на променлива. Сведете го до по-кратък израз, който ползва
    тези променливи.
